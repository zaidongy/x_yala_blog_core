<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_yala_blog_core.BlackLists</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>BlackLists</name>
        <script><![CDATA[var BlackLists = Class.create();
BlackLists.prototype = {
    initialize: function() {},

    //returns an array of sys_ids of tracks that are blacklisted.
    getTrackIDs: function() {
		
        var blackList = [];
		
        var eps = new GlideScriptedExtensionPoint().getExtensions("x_yala_blog_core.PlaylistBlacklist");
		
		//if we do not have any extensionPoints, return the system property value..
		
		if(eps.length == 0){
			var propIds = gs.getProperty('x_yala_blog_core.track.black_list');
            if(propIds){
                blackList = propIds.split(',');
            }

            return blackList;
		}
		
        //past our return statement, so lets go through all of the extension points, building the list of sys_ids to return
        //that's right, this will add together all the extension points that "handle" this playlist!

        eps.forEach(function(ep, $index) {
            if (!ep.appliesTo && !ep.getBlacklist) {
                gs.error('No applies to function and no black list function... please ensure your extension point is setup correctly. Ignoring blacklist for now.');
            } else if (!ep.appliesTo && ep.getBlacklist) {
                gs.warn('Did not have an applies to function, so assuming this applies to everything!');
                eps.length = index + 1;
            } else if (ep.appliesTo && ep.getBlacklist) {
                //gs.info('Has applies to!');
                if (ep.appliesTo(parent)) {
                    var blackListSysIds = ep.getBlacklist(parent);
                    if(blackListSysIds && blackListSysIds.length && blackListSysIds.length > 0){
                        blackList = blackList.concat(blackListSysIds);
                    }
                }
            }
        });
        return blackList;
    },

    type: 'BlackLists'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>nate.anderson</sys_created_by>
        <sys_created_on>2023-05-03 21:37:20</sys_created_on>
        <sys_id>1c1ba496872e695010aa848e8bbb35b1</sys_id>
        <sys_mod_count>3</sys_mod_count>
        <sys_name>BlackLists</sys_name>
        <sys_package display_value="Yansa Blog - CORE" source="x_yala_blog_core">d2ad3d03474aa110c4903fcbd36d43c2</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Yansa Blog - CORE">d2ad3d03474aa110c4903fcbd36d43c2</sys_scope>
        <sys_update_name>sys_script_include_1c1ba496872e695010aa848e8bbb35b1</sys_update_name>
        <sys_updated_by>nate.anderson</sys_updated_by>
        <sys_updated_on>2023-05-04 03:18:39</sys_updated_on>
    </sys_script_include>
</record_update>
