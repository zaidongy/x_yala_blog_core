<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_yala_blog_core.MusicDataGenerator</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>MusicDataGenerator</name>
        <script><![CDATA[var MusicDataGenerator = Class.create();
MusicDataGenerator.prototype = {

    _externalUpdateFuncWarningSent: [],
    _haveBeenCancelledCheck: function(){
    },
    /**
     * 
     * @param {"ARTIST" | "ALBUM" | "TRACK" |"ERROR" | "INFO"} type the type of item being broadcast
     * @param {number} count 
     * @param {string} msg the message sent along mostly used for errors.
     */
    _externalUpdateFunc: function (type, count, msg) {
        //this is where you can set / update your GlideRecord, or do other things...
        //types will be "ARTIST" | "ALBUM" | "TRACK"
        if (this._externalUpdateFuncWarningSent.indexOf(type) == -1) {
            this._externalUpdateFuncWarningSent.push(type)
            gs.warn('External updater func called with default, which does nothing. Consider passing in an updater func.');
        }
    },

    /**
     * Yansa logging library
     * 
     * @param {x_yala_blog_core.SystemLogHelper} logger Logging library that has already be instantiated. Note: if not provided will kick you out of cumulative mode!
     * 
     */
    initialize: function (logger) {
        var func = "initialize";
    },

    setHaveBeenCancelledCheck: function(func){
        if(func){
            this._haveBeenCancelledCheck = func;
        } else {
            this._haveBeenCancelledCheck = function(){};
        }
        
    },

    haveBeenCancelledCheck: function(){
        return this._haveBeenCancelledCheck();
    },

    /**
     * 
     * @param {} aFunction A function that is called with the inputs of the "type" and Count being updated
     */
    setExternalUpdaterFunc: function (aFunction) {
        this._externalUpdateFunc = aFunction;
    },

    loadAll: function () {
        this._externalUpdateFunc("INFO", 0, "Started loading all")
        this.loadArtists();
        this.loadAlbums();
        this.loadSongs();
        this._externalUpdateFunc("INFO", 0, "Fininshed loading all")
    },

    loadSongs: function () {

        var albums = new GlideRecord('x_yala_blog_core_album');
        albums.query();
        while (albums.next()) {
            if(this.haveBeenCancelledCheck()){
                this._externalUpdateFunc("INFO", 0, "LOADER WAS CANCELLED! ABORTING!");
                break;
            }
            var tracks = this.getAllTracks(albums.getValue('correlation_id'));
            tracks.forEach(function (track) {
                var songsGR = new GlideRecord('x_yala_blog_core_song');
                songsGR.addQuery('correlation_id', track.id);
                songsGR.query();
                if (songsGR.next()) {
                    songsGR.name = track.name;
                    songsGR.correlation_id = track.id;
                    songsGR.duration = new GlideDuration(track.duration_ms);
                    songsGR.album = albums.getValue('sys_id');
                    songsGR.update();
                } else {
                    songsGR.newRecord();
                    songsGR.name = track.name;
                    songsGR.correlation_id = track.id;
                    songsGR.duration = new GlideDuration(track.duration_ms);
                    songsGR.album = albums.getValue('sys_id');
                    songsGR.insert();
                }
            });
            this._externalUpdateFunc("TRACK", tracks.length);
        }

    },

    /**
     * 
     * @param {string} albumId The id of the album
     * @param {string} nextURL The url containing more tracks
     * @param {any[]} items The accumulator of tracks
     * @returns {any[]}
     */
    getAllTracks: function (albumId, nextURL, items) {
        if (!items) {
            items = [];
        }

        var rMsg = new sn_ws.RESTMessageV2();
        rMsg.setHttpMethod('GET');
        rMsg.setRequestHeader('Authorization', 'Bearer ' + this.getAccessToken());
        rMsg.setRequestHeader('Content-Type', 'application/json');
        if (!nextURL) {
            q = '&market=US&limit=50';
            rMsg.setEndpoint('https://api.spotify.com/v1/albums/' + albumId + '/tracks?' + q);
        } else {
            rMsg.setEndpoint(nextURL);
        }

        var resp = rMsg.execute();
        var status = resp.getStatusCode();
        if (status != 200) {
            gs.error('ERROR!\n' + resp.getBody());
            if(resp.getBody().indexOf('Too many requests') > -1){
                return this.getAllTracks(albumId, nextURL, items);
            }
            return items;
        } else {
            var resData = JSON.parse(resp.getBody());
            var returnedItems = resData.items;
            returnedItems.forEach(function (item) {
                items.push({ name: item.name, id: item.id, duration_ms: item.duration_ms });
            });

            //if (resData.next) {
            //  return this.getAllAlbums(artistId, resData.next, items);
            //} else {
            return items;
            //}
        }
    },

    loadAlbums: function (forceRefresh) {

        var artists = new GlideRecord('x_yala_blog_core_artist');
        if(!forceRefresh){
            artists.addEncodedQuery('albums_last_refreshedISEMPTY');
        }
        artists.query();
        while (artists.next()) {
            if(this.haveBeenCancelledCheck()){
                this._externalUpdateFunc("INFO", 0, "LOADER WAS CANCELLED! ABORTING!");
                break;
            }
            var albums = this.getAllAlbums(artists.getValue('correlation_id'));
            albums.forEach(function (album) {
                var albumGR = new GlideRecord('x_yala_blog_core_album');
                albumGR.addQuery('correlation_id', album.id);
                albumGR.query();
                if (!albumGR.hasNext()) {
                    albumGR.newRecord();
                    albumGR.name = album.name;
                    albumGR.correlation_id = album.id;
                    albumGR.artist = artists.getValue('sys_id')
                    albumGR.insert();
                } else if (albumGR.next()) {
                    albumGR.name = album.name;
                    albumGR.correlation_id = album.id;
                    albumGR.artist = artists.getValue('sys_id')
                    albumGR.update();
                }
            });
            artists.albums_last_refreshed = new GlideDateTime();
            artists.update();
            this._externalUpdateFunc("ALBUM", albums.length)
        }

    },

    /**
     * 
     * @param {string} artistId The artist identifier
     * @param {string} nextURL The next URL that has more albums
     * @param {any[]} items The album item
     * @returns {any[]}
     */
    getAllAlbums: function (artistId, nextURL, items) {

        if (!items) {
            items = [];
        }

        var rMsg = new sn_ws.RESTMessageV2();
        rMsg.setHttpMethod('GET');
        rMsg.setRequestHeader('Authorization', 'Bearer ' + this.getAccessToken());
        rMsg.setRequestHeader('Content-Type', 'application/json');
        if (!nextURL) {
            q = '&market=US&limit=50';
            rMsg.setEndpoint('https://api.spotify.com/v1/artists/' + artistId + '/albums?' + q);
        } else {
            rMsg.setEndpoint(nextURL);
        }

        var resp = rMsg.execute();
        var status = resp.getStatusCode();
        if (status != 200) {
            this._externalUpdateFunc("ERROR", 0, JSON.stringify({statusCode: resp.getStatusCode(), body: resp.getBody()}));
            gs.error('ERROR!\n' + resp.getBody());
            if(resp.getBody().indexOf('Too many requests') > -1){
                return this.getAllAlbums(artistId, nextURL, items);
            }
            return items;
        } else {
            var resData = JSON.parse(resp.getBody());
            var returnedItems = resData.items;
            returnedItems.forEach(function (item) {
                items.push({ name: item.name, id: item.id, type: item.type });
            });

            return items;

        }
        
    },


    loadArtists: function () {
        this._externalUpdateFunc("INFO", 0, "Started loading Artists");
        var maxCharacters = 26;

        for (var i = 0; i < maxCharacters; i++) {
            var character = (i + 10).toString(36);
            var artists = this.searchToMaxAmount(character, 'artist');
            if(this.haveBeenCancelledCheck()){
                this._externalUpdateFunc("INFO", 0, "LOADER WAS CANCELLED! ABORTING!");
                break;
            }
            artists.forEach(function (artist) {
                var artistGR = new GlideRecord('x_yala_blog_core_artist');
                artistGR.addQuery('correlation_id', artist.id);
                artistGR.query();
                if (!artistGR.next()) {
                    artistGR.newRecord();
                    artistGR.name = artist.name;
                    artistGR.correlation_id = artist.id;
                    artistGR.insert();
                }
            });

            this._externalUpdateFunc("ARTIST", artists.length);
        }
        this._externalUpdateFunc("INFO", 0, "Finished Loading Artists");
    },

    /**
     * 
     * @param {string} searchText The text to search
     * @param {string} type The type of thing we are searching
     * @returns {any[]}
     */
    searchToMaxAmount: function (searchText, type) {
        if (!searchText) {
            throw new Error('No search text provided!');
        }

        var items = this.getSearchResults([], searchText, type);

        return items;

    },

    getSearchResults: function (items, searchText, type, nextURL) {
        var rMsg = new sn_ws.RESTMessageV2();
        rMsg.setHttpMethod('GET');
        rMsg.setRequestHeader('Authorization', 'Bearer ' + this.getAccessToken());
        rMsg.setRequestHeader('Content-Type', 'application/json');
        if (!nextURL) {
            q = 'q=' + encodeURIComponent(searchText) + '&type=' + type + '&market=US&limit=50';
            rMsg.setEndpoint('https://api.spotify.com/v1/search?' + q);
        } else {
            rMsg.setEndpoint(nextURL);
        }

        var resp = rMsg.execute();
        var status = resp.getStatusCode();
        if (status != 200) {
            gs.error('ERROR!\n' + resp.getBody());
            this._externalUpdateFunc("ERROR", 0, JSON.stringify({statusCode: resp.getStatusCode(), body: resp.getBody()}));
            if(resp.getBody().indexOf('Too many requests') > -1){
                return this.getSearchResults(items, searchText, type, nextURL);
            }
            return items;
        } else {
            var resData = JSON.parse(resp.getBody());
            var returnedItems = resData[type + 's'].items;
            returnedItems.forEach(function (item) {
                items.push({ name: item.name, id: item.id, type: type });
            });

            if (resData[type + 's'].next) {
                return this.getSearchResults(items, searchText, type, resData[type + 's'].next)
            } else {
                return items;
            }
        }
    },



    getAccessToken: function () {
        var oAuthClient = new sn_auth.GlideOAuthClient();
        var token = oAuthClient.getToken('f44691228721651010aa848e8bbb355b', '84cb9b071b42e1101272624abc4bcb85');
        var expiresIn = token.getExpiresIn();
        if (expiresIn === 0) {
            this._externalUpdateFunc("INFO", 0, "Token expired, getting a new one!");
            var refreshToken = token.getRefreshToken();
            var tResp = oAuthClient.requestToken('Spotify', JSON.stringify({ grant_type: "refresh_token", refresh_token: refreshToken }));
            token = tResp.getToken();
            var tokenGR = new GlideRecord('oauth_credential');
            tokenGR.addQuery('peer', 'f85b1bc71b42e1101272624abc4bcb26');
            tokenGR.query();
            while (tokenGR.next()) {
                if (tokenGR.type == 'refresh_token') {
                    var refreshGDT = new GlideDateTime();
                    refreshGDT.addSeconds(tokenGR.peer.refresh_token_lifespan);
                    tokenGR.expires = refreshGDT;
                    tokenGR.token_received.setDisplayValue(token.getAccessToken() + '');
                    tokenGR.update();
                }

                if (tokenGR.type == 'access_token') {
                    var accessGDT = new GlideDateTime();
                    accessGDT.addSeconds(token.getExpiresIn());
                    tokenGR.expires = accessGDT;
                    tokenGR.token_received.setDisplayValue(token.getAccessToken() + '');
                    tokenGR.update();
                }
            }
        }



        return token.getAccessToken();
    },


    type: 'MusicDataGenerator'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>nate.anderson</sys_created_by>
        <sys_created_on>2023-03-16 03:59:38</sys_created_on>
        <sys_id>77cffd071b0ea1101272624abc4bcb28</sys_id>
        <sys_mod_count>59</sys_mod_count>
        <sys_name>MusicDataGenerator</sys_name>
        <sys_package display_value="Yansa Blog - CORE" source="x_yala_blog_core">d2ad3d03474aa110c4903fcbd36d43c2</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Yansa Blog - CORE">d2ad3d03474aa110c4903fcbd36d43c2</sys_scope>
        <sys_update_name>sys_script_include_77cffd071b0ea1101272624abc4bcb28</sys_update_name>
        <sys_updated_by>nate.anderson</sys_updated_by>
        <sys_updated_on>2023-04-13 03:18:20</sys_updated_on>
    </sys_script_include>
</record_update>
